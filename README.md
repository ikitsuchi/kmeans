# 华科七边形 2021 秋季招新试题解答

https://github.com/heptagonhust/recruitment-2021-autumn

## 设备信息

CPU: AMD Ryzen 7 5800HS Creator Edition (8C16T) @3.200GHz

RAM: 16GB LPDDR4 @4266MHz

## 优化方法

最初，不进行任何优化，程序运行时长 `20.4943s`。

### 合并多余的循环

一眼就看到有两个可以合起来的循环，就嗯合并。

优化后程序运行时长 `20.2776s`，几乎什么都没有发生。

### 消除连续的函数调用

用 gprof 分析后发现 Distance 函数居然占了高达 42.7% 的运行时间。观察发现这个函数内容极度简单，疯狂调用函数开销很大，可以用 inline 优化一下。

优化后程序运行时长 `6.87372s`，相对于原代码，速度提升了 2.982 倍，效果拔群！

### 消除不必要的内存引用

在划分点集的循环中 assignment 数组被不断的引用，但它只需要得到比较的最终值，可以用一个中间变量去当比较的替死鬼以减少内存的引用。

优化后程序运行时长 `2.40719s`，相对于原代码，速度提升了 8.514 倍，效果非常 nice。

### 使用 OpenMP 进行并行优化

划分点集的大循环计算量非常庞大，考虑用多线程优化它。

优化后程序运行时长 `1.4886s`，相对于原代码，速度提升了 13.732 倍，已经非常接近题面的 15.6 倍了！

#### 困惑

如果我对后面两个维护点集的循环也套用多线程，程序运行时间反而会劣化到 `25.2207s`，这是为什么？

猜想：这两个循环耗时本来就不长，套上多线程产生线程的时间都比正常运行时间长。

### 瓶颈：load imbalance

经高人指点后，使用 AMDuProf 分析发现 gomp_barrier_wait_end 占比 68.28% ，同步的时间比计算还长。

于是尝试添加 dynamic 调度子句，结果程序运行时间劣化到 `4.24155s`，这次是 gomp_iter_dynamic_next 占了 57.17%，任务动态申请的开销太大。

多次修改 chunk，程序运行时间始终无法突破 `1.7s`，甚至还不如不用 dynamic 调度。遂放弃。

### 优化收敛的判断方式

原代码对于收敛的判断是利用的 vector 的比较，然而 vector 比较是 O(n) 的，可以用一个记录是否修改过的标志变量代替。

这里还有个优化，就是我在后面的循环有个引用用的并不恰当，属于是负优化，我把它去掉了。

优化后程序运行时长 `1.18603s`，相对于原代码，速度提升了 17.280 倍。

## 参考资料

* CS:APP Chapter 5

* [Guide into OpenMP: Easy multithreading programming for C++](https://bisqwit.iki.fi/story/howto/openmp/#Abstract)